#+SETUPFILE: ./Setup/setupFile.org
#+TITLE: Pragmatic automatic differentiation
#+PROPERTY: header-args:julia :session *pad_session*  :exports code :eval no-export
#+LATEX_HEADER: \usepackage{stmaryrd}

#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted[]{
  bgcolor=bg,
  breaklines=true,
  breakanywhere=true,
  mathescape,
  fontsize=\footnotesize}
#+END_EXPORT

#+BEGIN_SRC julia :exports none
using Revise
using PragmaticAD
using J4Org

initialize_boxing_module(usedModules=["PragmaticAD"])
#+END_SRC

#+RESULTS:

* Introduction

* API documentation 

  #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/PragmaticAD.jl/src/");
print_org_doc(documented_items,tag="API",header_level=0)
  #+END_SRC

  #+RESULTS:
  :RESULTS:

<<iKkCchMr>> *Index:* *[A]* [[bXIf1ThZ][AArray]], [[XrCKNICr][AFloat]] 
- @@latex:\phantomsection@@ *=AArray=*  <<bXIf1ThZ>> <<pGeIM1vnAArray>>
#+BEGIN_SRC julia :eval never :exports code
struct AArray{AT<:AFloat,N,P<:AbstractArray,AIDX}  <: AbstractArray{AT,N}
#+END_SRC
#+BEGIN_QUOTE
This is the array type to use in place of built-in Julia =Array{T,N}= types.

*Parameters*:

- =AIDX= is an extra parameter defining how [[pGeIM1vnAFloat][struct AFloat]] indices are
  stored. This type can be different from =P=. For instance in case
  of sparse matrix, only an uni-dimensional array to store indices
  associated to non-zero components is required, no need to the
  store sparsity pattern twice. 

*Design*:
- [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]

#+END_QUOTE
[[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::3][array.jl:3]], [[iKkCchMr][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function AArray(p::Array{T,N}) where {T<:AbstractFloat,N}
#+END_SRC
#+BEGIN_QUOTE
Construction from an "usual" Julia array of real numbers.

Usage example:

#+BEGIN_SRC julia
AArray(rand(2,1))
#+END_SRC

#+RESULTS:
| PragmaticAD.AFloat{Float64}(0.24475618878823702 | 15) |
| PragmaticAD.AFloat{Float64}(0.7719785904922678  | 16) |

#+BEGIN_SRC julia
2×1 PragmaticAD.AArray{PragmaticAD.AFloat{Float64},2,Array{Float64,2},Array{Int64,2}}:
 PragmaticAD.AFloat{Float64}(0.575999, 13)
 PragmaticAD.AFloat{Float64}(0.524417, 14)
#+END_SRC

#+RESULTS:
| PragmaticAD.AFloat{Float64}(0.524417 | 14) |

*Design*:
- [[id:b384f347-8c27-42ae-9759-2914d67cad4d][Restricted set of constructors]]
#+END_QUOTE
[[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::22][array.jl:22]], [[iKkCchMr][back to index]]
- @@latex:\phantomsection@@ *=AFloat=*  <<XrCKNICr>> <<pGeIM1vnAFloat>>
#+BEGIN_SRC julia :eval never :exports code
struct AFloat{T<:AbstractFloat} <: Real
#+END_SRC
#+BEGIN_QUOTE
Specialization of number alllowing to track and record operations in the _struct Tape_
#+END_QUOTE
[[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::35][tape.jl:35]], [[iKkCchMr][back to index]]
  :END:

* Internal documentation

  #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/PragmaticAD.jl/src/");
print_org_doc(documented_items,link_prefix="All_", header_level=0)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # =WARNING:= cannot interpret /home/picaud/GitHub/PragmaticAD.jl/src/array.jl:3 AssertionError("code != nothing")
  # =WARNING:= cannot interpret /home/picaud/GitHub/PragmaticAD.jl/src/array.jl:134 AssertionError("code != nothing")
  # =WARNING:= cannot interpret /home/picaud/GitHub/PragmaticAD.jl/src/array.jl:142 AssertionError("code != nothing")
  # =WARNING:= cannot interpret /home/picaud/GitHub/PragmaticAD.jl/src/array.jl:155 AssertionError("code != nothing")
  <<ho6tOInJ>> *Index:* *[A]* [[6sPuEoD6][AArray]], [[LWjP364F][AFloat]] *[B]* [[uRLdGxPI][Base.push!]] *[I]* [[pHKWAxXk][IndexStyle]] *[T]* [[UijFbbpt][Tape]] *[a]* [[bYK5zHcp][afloat_count]], [[ZGySLI8E][afloat_next_index]], [[jYfzTV6i][aidx]], [[HApKzwQK][aidx_type]] *[c]* [[pPkkY2Lh][create_tape_chunk]], [[0i67yetI][create_tape_record]] *[e]* [[neJnUUrp][export]] *[f]* [[Ux5kI0hb][f_gradient]] *[g]* [[YBk7G9Dj][getindex]] *[i]* [[8Ax9xbOe][increase_size!]] *[p]* [[dWL6E4sL][parent]], [[uk0HhRrc][parent_type]] *[r]* [[yP0ZNYK5][rewind_tape!]] *[s]* [[1ITvI4op][size]] *[t]* [[1kHs2oUO][tape_position]] *[∂]* [[OjgTcZh2][∂_j]] 
  - @@latex:\phantomsection@@ *=AArray=*  <<6sPuEoD6>> <<All_AArray>>
  #+BEGIN_SRC julia :eval never :exports code
  struct AArray{AT<:AFloat,N,P<:AbstractArray,AIDX}  <: AbstractArray{AT,N}
  #+END_SRC
  #+BEGIN_QUOTE
  This is the array type to use in place of built-in Julia =Array{T,N}= types.

  *Parameters*:

  - =AIDX= is an extra parameter defining how [[All_AFloat][struct AFloat]] indices are
    stored. This type can be different from =P=. For instance in case
    of sparse matrix, only an uni-dimensional array to store indices
    associated to non-zero components is required, no need to the
    store sparsity pattern twice. 

  *Design*:
  - [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]

  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::6][array.jl:6]], [[ho6tOInJ][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  function AArray(p::Array{T,N}) where {T<:AbstractFloat,N}
  #+END_SRC
  #+BEGIN_QUOTE
  Construction from an "usual" Julia array of real numbers.

  Usage example:

  #+BEGIN_SRC julia
  AArray(rand(2,1))
  #+END_SRC
  #+BEGIN_SRC julia
  2×1 PragmaticAD.AArray{PragmaticAD.AFloat{Float64},2,Array{Float64,2},Array{Int64,2}}:
   PragmaticAD.AFloat{Float64}(0.719349, 27) 
   PragmaticAD.AFloat{Float64}(0.0908467, 28)
  #+END_SRC

  *Design*:
  - [[id:b384f347-8c27-42ae-9759-2914d67cad4d][Restricted set of constructors]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::25][array.jl:25]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=AFloat=*  <<LWjP364F>> <<All_AFloat>>
  #+BEGIN_SRC julia :eval never :exports code
  struct AFloat{T<:AbstractFloat} <: Real
  #+END_SRC
  #+BEGIN_QUOTE
  Specialization of number alllowing to track and record operations in the [[All_Tape][struct Tape]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::41][tape.jl:41]], [[ho6tOInJ][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  AFloat{T}(value::S) where {T<:AbstractFloat,S<:Real}
  #+END_SRC
  #+BEGIN_QUOTE
  Creates a new [[All_AFloat][struct AFloat]] from its value.
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::50][tape.jl:50]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=Base.push!=*  <<uRLdGxPI>>
  #+BEGIN_SRC julia :eval never :exports code
  function Base.push!{T,N}(v::Array{T,1},x::NTuple{N,T})::Array{T,1}
  #+END_SRC
  #+BEGIN_QUOTE
  A helper function that push a NTuple into an array
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::80][tape.jl:80]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=IndexStyle=*  <<pHKWAxXk>>
  #+BEGIN_SRC julia :eval never :exports code
  IndexStyle(::Type{<:AArray{AT,N,P,AIDX}}) where {AT,N,P,AIDX}
  #+END_SRC
  #+BEGIN_QUOTE
  *Design*:
  - [[id:1b16ffef-47fa-473c-b033-de4a864dcaf3][Interface, main methods to redefine]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::119][array.jl:119]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=Tape=*  <<UijFbbpt>> <<All_Tape>>
  #+BEGIN_SRC julia :eval never :exports code
  mutable struct Tape{T<:AbstractFloat}
  #+END_SRC
  #+BEGIN_QUOTE
  Used to store $d\Phi^{(m)}$ using a storage scheme close to the
  Compressed Row Storage (CRS)

  *Note:* we use =mutable= to have a "by reference" semantic to avoid
   having a tape copy (which would be catastrophic).
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::14][tape.jl:14]], [[ho6tOInJ][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  function Tape{T<:AbstractFloat}(::Type{T},tape_initial_size::Int = 100)
  #+END_SRC
  #+BEGIN_QUOTE
  Tape constructor
  #+BEGIN_SRC julia
  PragmaticAD.Tape(Float64)
  #+END_SRC
  #+BEGIN_SRC julia
  PragmaticAD.Tape{Float64}([1], PragmaticAD.∂_j{Float64}[])
  #+END_SRC
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::27][tape.jl:27]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=afloat_count=*  <<bYK5zHcp>>
  #+BEGIN_SRC julia :eval never :exports code
  afloat_count{T}(tape::Tape{T})::Int
  #+END_SRC
  #+BEGIN_QUOTE
  Returns how many [[All_AFloat][struct AFloat]] are stored in the current [[All_Tape][struct Tape]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::74][tape.jl:74]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=afloat_next_index=*  <<ZGySLI8E>>
  #+BEGIN_SRC julia :eval never :exports code
  afloat_next_index{T}(tape::Tape{T})::Int
  #+END_SRC
  #+BEGIN_QUOTE
  Returns a new [[All_AFloat][struct AFloat]] index. Generally used at creation time,
  see [[All_create_tape_record_value][create_tape_record(...)]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::67][tape.jl:67]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=aidx=*  <<jYfzTV6i>>
  #+BEGIN_SRC julia :eval never :exports code
  aidx(aa::AArray)
  #+END_SRC
  #+BEGIN_QUOTE
  The recommended way to access aidx member

  See [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::85][array.jl:85]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=aidx_type=*  <<HApKzwQK>>
  #+BEGIN_SRC julia :eval never :exports code
  aidx_type(::Type{AArray{AT,N,P,AIDX}}) where {AT,N,P,AIDX}
  #+END_SRC
  #+BEGIN_QUOTE
  The recommended way to access aidx member *type*

  See [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::77][array.jl:77]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=create_tape_chunk=*  <<pPkkY2Lh>>
  #+BEGIN_SRC julia :eval never :exports code
  function create_tape_chunk(tape::Tape{T},chunk_n::Int) where {T}
  #+END_SRC
  #+BEGIN_QUOTE
  This function allocate a chunk of =chunk_n= new [[All_AFloat][struct AFloat]].
  It returns the index of the first one.
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::57][array.jl:57]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=create_tape_record=*  <<0i67yetI>>
  #+BEGIN_SRC julia :eval never :exports code
  function create_tape_record{T,N}(tape::Tape{T},value::T,dϕ::NTuple{N,∂_j{T}})::AFloat{T}
  #+END_SRC
  #+BEGIN_QUOTE
  Creates a new differential $d\phi = \sum \partial_j d x_j$ and
  returns the [[All_AFloat][struct AFloat]] associated to $d\phi$.
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::93][tape.jl:93]], [[ho6tOInJ][back to index]]
   @@latex:\phantomsection@@  <<All_create_tape_record_value>>
  #+BEGIN_SRC julia :eval never :exports code
  function create_tape_record{T}(tape::Tape{T},value::T)::AFloat{T}
  #+END_SRC
  #+BEGIN_QUOTE
  Creates a new [[All_AFloat][struct AFloat]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::106][tape.jl:106]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=export=*  <<neJnUUrp>>
  #+BEGIN_SRC julia :eval never :exports code
  export AFloat, afloat_count
  #+END_SRC
  #+BEGIN_QUOTE
  Exported symbols
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::1][tape.jl:1]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=f_gradient=*  <<Ux5kI0hb>>
  #+BEGIN_SRC julia :eval never :exports code
  function f_gradient{T}(tape::Tape{T},
			 index::Int,
			 stop_at_tape_position::Int)
  #+END_SRC
  #+BEGIN_QUOTE
  Computes differential adjoint vector action (reverse mode)
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::153][tape.jl:153]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=getindex=*  <<YBk7G9Dj>>
  #+BEGIN_SRC julia :eval never :exports code
  getindex(aa::AArray{AT}, i::Int) where {AT}
  #+END_SRC
  #+BEGIN_QUOTE
  *Design*:
  - [[id:1b16ffef-47fa-473c-b033-de4a864dcaf3][Interface, main methods to redefine]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::126][array.jl:126]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=increase_size!=*  <<8Ax9xbOe>>
  #+BEGIN_SRC julia :eval never :exports code
  function increase_size!(v::Array{T,1},positive_integer::Int)::Int where {T}
  #+END_SRC
  #+BEGIN_QUOTE
  This function increase array size by =positive_integer= and returns
  the initial size
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::46][array.jl:46]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=parent=*  <<dWL6E4sL>>
  #+BEGIN_SRC julia :eval never :exports code
  parent(aa::AArray)
  #+END_SRC
  #+BEGIN_QUOTE
  The recommended way to access parent membe

  See [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::101][array.jl:101]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=parent_type=*  <<uk0HhRrc>>
  #+BEGIN_SRC julia :eval never :exports code
  parent_type(::Type{AArray{AT,N,P,AIDX}}) where {AT,N,P,AIDX}
  #+END_SRC
  #+BEGIN_QUOTE
  The recommended way to access parent member *type*

  See [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::93][array.jl:93]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=rewind_tape!=*  <<yP0ZNYK5>> <<All_rewind_tape>>
  #+BEGIN_SRC julia :eval never :exports code
  function rewind_tape!{T}(tape::Tape{T},tape_position::Int)
  #+END_SRC
  #+BEGIN_QUOTE
  Rewinds tape

  See: [tape_position[][]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::122][tape.jl:122]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=size=*  <<1ITvI4op>>
  #+BEGIN_SRC julia :eval never :exports code
  size(aa::AArray)
  #+END_SRC
  #+BEGIN_QUOTE
  *Design*:
  - [[id:1b16ffef-47fa-473c-b033-de4a864dcaf3][Interface, main methods to redefine]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::112][array.jl:112]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=tape_position=*  <<1kHs2oUO>> <<All_tape_position>>
  #+BEGIN_SRC julia :eval never :exports code
  tape_position{T}(tape::Tape{T})
  #+END_SRC
  #+BEGIN_QUOTE
  Returns tape position.

  See: [rewind_tape[][]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::115][tape.jl:115]], [[ho6tOInJ][back to index]]
  - @@latex:\phantomsection@@ *=∂_j=*  <<OjgTcZh2>>
  #+BEGIN_SRC julia :eval never :exports code
  struct ∂_j{T<:Real}
  #+END_SRC
  #+BEGIN_QUOTE
  Used to store partial derivatives $\partial_j$
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::7][tape.jl:7]], [[ho6tOInJ][back to index]]
  :END:

* Design remarks 
** Array struct design

   The global design has been inspired from these Julia packages:
   - [[https://github.com/JuliaArrays/OffsetArrays.jl/blob/master/src/OffsetArrays.jl][OffsetArrays.jl]]
   - [[https://github.com/JuliaArrays/StaticArrays.jl][StaticArrays.jl]]

*** Multiple parameters in the struct definition 
    :PROPERTIES:
    :ID:       c39435d9-532c-4390-8089-bde4c5e53f3e
    :END:
    The [[All_AArray][AArray]] class can possibly have a quite large number of parameters
    (here =T,N,AIDX,O=). In order to decouple this parametrization from
    the future method implementations we use the following guideline.

    Define =foo= as follows:
    #+BEGIN_SRC julia :eval never 
foo(aa:AArray) = ...
    #+END_SRC
    and not as follows:
    #+BEGIN_SRC julia :eval never 
foo(aa::AArray{T,N,P,AIDX}) where {T,N,P,AIDX} = ...
    #+END_SRC
    In this former code we see that any change in the parameter lists will break =foo= function code.

    As a consequence, one must define a *restricted number* of helper
    functions like
    #+BEGIN_SRC julia :eval never 
aidx_type(::Type{AArray{T,N,P,AIDX}}) where {T,N,P,AIDX} = AIDX
... same for T,N,P and that is all!
    #+END_SRC

*** Restricted set of constructors
    :PROPERTIES:
    :ID:       b384f347-8c27-42ae-9759-2914d67cad4d
    :END:

    There are a lot of Array types in Julia 
    #+BEGIN_EXAMPLE
julia> subtypes(AbstractArray)
24-element Array{Union{DataType, UnionAll},1}:
 AbstractSparseArray                      
 Bidiagonal                               
 ConjArray                                
 Core.Inference.Range                     
 DenseArray                               
 ...
    #+END_EXAMPLE
    with some variations that can lead to unexpected bugs if we blindly use a generic approach.
    In order to control type variability we use an inner constructor. From Julia doc:
    #+BEGIN_QUOTE
    Without any explicitly provided inner constructors, the declaration of
    the composite type Point{T<:Real} automatically provides an inner
    constructor, Point{T}, for each possible type T<:Real, that behaves
    just like non-parametric default inner constructors do. It also
    provides a single general outer Point constructor that takes pairs of
    real arguments, which must be of the same type.
    #+END_QUOTE

    This mechanism allows use to explicitly control available implementations:

    #+BEGIN_SRC julia :eval never
julia> struct X{T}
           x::T

           X(n::I) where {I<:Integer} = new{I}(n)
       end

julia> X(5)
X{Int64}(5)

julia> X(5.0)
ERROR: MethodError: Cannot `convert` an object of type Float64 to an object of type X
This may have arisen from a call to the constructor X(...),
since type constructors fall back to convert methods.
Stacktrace:
 [1] X(::Float64) at ./sysimg.jl:77
    #+END_SRC

*** Interface, main methods to redefine
    :PROPERTIES:
    :ID:       1b16ffef-47fa-473c-b033-de4a864dcaf3
    :END:


    Methods to implement can be found [[https://docs.julialang.org/en/stable/manual/interfaces/#man-interface-array-1][here]] (official julia doc)

    The idea is to reuse as much a possible =parent='s methods.

**** Remark
     :PROPERTIES:
     :ID:       ffb7408e-cb7b-4c7e-a1f8-39c3af3d37d5
     :END:

     CAVEAT: my first attempt was to write =getindex(parent(aa),I)= as follows:

     #+BEGIN_SRC julia :eval never
  @inline Base.getindex(aa::AArray{AT,N,P}, I::Vararg{Int, N}) where {AT,N,P} = AT(getindex(parent(aa),I...),getindex(aidx(aa),I...))
     #+END_SRC
     which gives this:
     #+BEGIN_EXAMPLE
ERROR: ArgumentError: invalid index: (1, 1)
Stacktrace:
[1] getindex(::Array{Float64,2}, ::Tuple{Int64,Int64}) at ./abstractarray.jl:883
     #+END_EXAMPLE
  
     The correct form is:
     #+BEGIN_SRC julia :eval never
  @inline Base.getindex(aa::AArray{AT,N,P}, I::Vararg{Int, N}) where {AT,N,P} = AT(getindex(parent(aa),I...),getindex(aidx(aa),I...))
     #+END_SRC

**** TODO [0/1]

- [ ] implement:
#+BEGIN_EXAMPLE
function Base.similar(aa::AArray{T,N,P}, ::Type{TS}, dims::Dims) where {T,TS,N,P}
    return similar(parent(A), T, dims)
end
#+END_EXAMPLE

* Unit tests

  #+BEGIN_SRC julia :results output table :exports results
include("/home/picaud/GitHub/PragmaticAD.jl/test/runtests.jl")
  #+END_SRC

  #+RESULTS:
  : Test Summary: | Pass  Total
  : PragmaticAD   |    2      2
