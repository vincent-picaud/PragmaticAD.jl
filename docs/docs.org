#+SETUPFILE: ./Setup/setupFile.org
#+TITLE: Pragmatic automatic differentiation
#+PROPERTY: header-args:julia :session *pad_session*  :exports code :eval no-export
#+LATEX_HEADER: \usepackage{stmaryrd}

#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted[]{
  bgcolor=bg,
  breaklines=true,
  breakanywhere=true,
  mathescape,
  fontsize=\footnotesize}
#+END_EXPORT

#+BEGIN_SRC julia :exports none
using Revise
using PragmaticAD
using J4Org

initialize_boxing_module(usedModules=["PragmaticAD"])
#+END_SRC

#+RESULTS:

* Introduction

* API documentation 

  #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/PragmaticAD.jl/src/");
print_org_doc(documented_items,tag="API",header_level=0)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # =WARNING:= cannot interpret /home/picaud/GitHub/PragmaticAD.jl/src/array.jl:3 AssertionError("code != nothing")
  # =WARNING:= cannot interpret /home/picaud/GitHub/PragmaticAD.jl/src/array.jl:135 AssertionError("code != nothing")
  # =WARNING:= cannot interpret /home/picaud/GitHub/PragmaticAD.jl/src/array.jl:143 AssertionError("code != nothing")
  # =WARNING:= cannot interpret /home/picaud/GitHub/PragmaticAD.jl/src/array.jl:156 AssertionError("code != nothing")
  <<ueLQtzOe>> *Index:* *[A]* [[zefr8szT][AArray]], [[kLRPnpVP][AFloat]], [[rtnBc5zW][AFloat32]], [[8FuqlpPW][AFloat64]] *[a]* [[7y5qUUNO][afloat_count]] *[e]* [[GheoDuti][export]] *[f]* [[bXncFIvD][f_∇f]] 
  - @@latex:\phantomsection@@ *=AArray=*  <<zefr8szT>> <<FzwL8LCfAArray>>
  #+BEGIN_SRC julia :eval never :exports code
  struct AArray{AT<:AFloat,N,P<:AbstractArray,AIDX}  <: AbstractArray{AT,N}
  #+END_SRC
  #+BEGIN_QUOTE
  This is the array type to use in place of built-in Julia =Array{T,N}= types.

  *Parameters*:

  - =AIDX= is an extra parameter defining how [[FzwL8LCfAFloat][struct AFloat]] indices are
    stored. This type can be different from =P=. For instance in case
    of sparse matrix, only an uni-dimensional array to store indices
    associated to non-zero components is required, no need to the
    store sparsity pattern twice. 

  *Design*:
  - [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]

  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::6][array.jl:6]], [[ueLQtzOe][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  function AArray(p::Array{T,N}) where {T<:AbstractFloat,N}
  #+END_SRC
  #+BEGIN_QUOTE
  Construction from an "usual" Julia array of real numbers.

  Usage example:

  #+BEGIN_SRC julia
  AArray(rand(2))
  AArray(rand(2,3))
  #+END_SRC
  #+BEGIN_SRC julia
  2-element PragmaticAD.AArray{PragmaticAD.AFloat{Float64},1,Array{Float64,1},Array{Int64,1}}:
   0.626796_52
    0.41198_53
  2×3 PragmaticAD.AArray{PragmaticAD.AFloat{Float64},2,Array{Float64,2},Array{Int64,2}}:
   0.615292_54  0.756405_56  0.908394_58
   0.605512_55   0.31803_57  0.168518_59
  #+END_SRC

  *Design*:
  - [[id:b384f347-8c27-42ae-9759-2914d67cad4d][Restricted set of constructors]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::25][array.jl:25]], [[ueLQtzOe][back to index]]
  - @@latex:\phantomsection@@ *=AFloat=*  <<kLRPnpVP>> <<FzwL8LCfAFloat>>
  #+BEGIN_SRC julia :eval never :exports code
  struct AFloat{T<:AbstractFloat} <: Number
  #+END_SRC
  #+BEGIN_QUOTE
  Specialization of number alllowing to track and record operations in the _struct Tape_

  - TODO [ ] support complex numbers (use [[https://en.wikipedia.org/wiki/Wirtinger_derivatives][Wirtinger_derivatives]]).
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/afloat.jl::4][afloat.jl:4]], [[ueLQtzOe][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  AFloat{T}(value::S) where {T<:AbstractFloat,S<:Real}
  #+END_SRC
  #+BEGIN_QUOTE
  Creates a new [[FzwL8LCfAFloat][struct AFloat]] from its value.

  #+BEGIN_SRC julia
  AFloat(-2.0)
  #+END_SRC
  #+BEGIN_SRC julia
  -2.0_60
  #+END_SRC
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/afloat.jl::14][afloat.jl:14]], [[ueLQtzOe][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  AFloat(value::T) where {T<:AbstractFloat}
  #+END_SRC
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/afloat.jl::21][afloat.jl:21]], [[ueLQtzOe][back to index]]
  - @@latex:\phantomsection@@ *=AFloat32=*  <<rtnBc5zW>>
  #+BEGIN_SRC julia :eval never :exports code
  const AFloat32
  #+END_SRC
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/global.jl::5][global.jl:5]], [[ueLQtzOe][back to index]]
  - @@latex:\phantomsection@@ *=AFloat64=*  <<8FuqlpPW>>
  #+BEGIN_SRC julia :eval never :exports code
  const AFloat64
  #+END_SRC
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/global.jl::9][global.jl:9]], [[ueLQtzOe][back to index]]
  - @@latex:\phantomsection@@ *=afloat_count=*  <<7y5qUUNO>>
  #+BEGIN_SRC julia :eval never :exports code
  afloat_count{T}(tape::Tape{T})::Int
  #+END_SRC
  #+BEGIN_QUOTE
  Returns how many [[FzwL8LCfAFloat][struct AFloat]] are stored in the current _struct Tape_
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::51][tape.jl:51]], [[ueLQtzOe][back to index]]
  - @@latex:\phantomsection@@ *=export=*  <<GheoDuti>>
  #+BEGIN_SRC julia :eval never :exports code
  export AFloat
  #+END_SRC
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/afloat.jl::1][afloat.jl:1]], [[ueLQtzOe][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  export afloat_count
  #+END_SRC
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::1][tape.jl:1]], [[ueLQtzOe][back to index]]
  - @@latex:\phantomsection@@ *=f_∇f=*  <<bXncFIvD>>
  #+BEGIN_SRC julia :eval never :exports code
  function f_∇f(f::Function, argnum::Int=1)
  #+END_SRC
  #+BEGIN_QUOTE
  Wraps a function to compute its value and gradient

  *Note*: inspired from [[https://github.com/denizyuret/AutoGrad.jl/blob/master/src/core.jl][AutoGrad.jl/core.jl]]

  Scalar example:

  #+BEGIN_SRC julia
   4+5
  #+END_SRC
  #+BEGIN_SRC julia
  9
  #+END_SRC
  R f(x,y) = y*sin(x)
  R af=PragmaticAD.f_∇f(f,2)
  R af(2,5.)


  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/wrapper.jl::30][wrapper.jl:30]], [[ueLQtzOe][back to index]]
  :END:

* Internal documentation

  #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/PragmaticAD.jl/src/");
print_org_doc(documented_items,link_prefix="All_", header_level=0)
  #+END_SRC

  #+RESULTS:
  :RESULTS:

  WARNING: Method definition f(Any, Any) in module BoxingModule at none:1 overwritten at none:1.
  # =WARNING:= An error occurred evaluating  af(2,5.)
  <<6AeX459r>> *Index:* *[A]* [[zDjPUZnT][AArray]], [[ZoQymVak][AFloat]], [[nGs1J6uV][AFloat32]], [[LxmiXjXf][AFloat64]] *[B]* [[zf7tYaeV][Base.push!]], [[Ukl9yGMh][Base.show]] *[I]* [[OEeK56QQ][IndexStyle]] *[T]* [[4WCK5yyI][Tape]] *[_]* [[VALruKDq][_f_∇f_input_float_to_afloat]], [[NA3RwPRX][_f_∇f_output_grad]] *[a]* [[YhyLyjGH][afloat_count]], [[GhrMzCNE][afloat_next_index]], [[PkT9cXFw][aidx]], [[fPSCBihY][aidx_type]] *[c]* [[aXCYcFtF][create_tape_chunk]], [[29uzBFDM][create_tape_record]] *[e]* [[8StxI6z4][export]] *[f]* [[c1QrUAM2][f_gradient]], [[49aDC1JX][f_∇f]] *[g]* [[lICJ7815][getindex]] *[i]* [[XJFOPg6b][increase_size!]] *[p]* [[jI6UaBxu][parent]], [[YYQzcLzV][parent_type]] *[r]* [[8xntlVkB][rewind_tape!]] *[s]* [[fybLT82T][size]] *[t]* [[4GpB304e][tape_position]] *[∂]* [[fh2PaPqA][∂_j]] 
  - @@latex:\phantomsection@@ *=AArray=*  <<zDjPUZnT>> <<All_AArray>>
  #+BEGIN_SRC julia :eval never :exports code
  struct AArray{AT<:AFloat,N,P<:AbstractArray,AIDX}  <: AbstractArray{AT,N}
  #+END_SRC
  #+BEGIN_QUOTE
  This is the array type to use in place of built-in Julia =Array{T,N}= types.

  *Parameters*:

  - =AIDX= is an extra parameter defining how [[All_AFloat][struct AFloat]] indices are
    stored. This type can be different from =P=. For instance in case
    of sparse matrix, only an uni-dimensional array to store indices
    associated to non-zero components is required, no need to the
    store sparsity pattern twice. 

  *Design*:
  - [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]

  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::6][array.jl:6]], [[6AeX459r][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  function AArray(p::Array{T,N}) where {T<:AbstractFloat,N}
  #+END_SRC
  #+BEGIN_QUOTE
  Construction from an "usual" Julia array of real numbers.

  Usage example:

  #+BEGIN_SRC julia
  AArray(rand(2))
  AArray(rand(2,3))
  #+END_SRC
  #+BEGIN_SRC julia
  2-element PragmaticAD.AArray{PragmaticAD.AFloat{Float64},1,Array{Float64,1},Array{Int64,1}}:
   0.708963_152
   0.111173_153
  2×3 PragmaticAD.AArray{PragmaticAD.AFloat{Float64},2,Array{Float64,2},Array{Int64,2}}:
   0.812261_154  0.293842_156   0.832244_158
   0.827891_155  0.241933_157  0.0801037_159
  #+END_SRC

  *Design*:
  - [[id:b384f347-8c27-42ae-9759-2914d67cad4d][Restricted set of constructors]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::25][array.jl:25]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=AFloat=*  <<ZoQymVak>> <<All_AFloat>>
  #+BEGIN_SRC julia :eval never :exports code
  struct AFloat{T<:AbstractFloat} <: Number
  #+END_SRC
  #+BEGIN_QUOTE
  Specialization of number alllowing to track and record operations in the [[All_Tape][struct Tape]]

  - TODO [ ] support complex numbers (use [[https://en.wikipedia.org/wiki/Wirtinger_derivatives][Wirtinger_derivatives]]).
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/afloat.jl::4][afloat.jl:4]], [[6AeX459r][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  AFloat{T}(value::S) where {T<:AbstractFloat,S<:Real}
  #+END_SRC
  #+BEGIN_QUOTE
  Creates a new [[All_AFloat][struct AFloat]] from its value.

  #+BEGIN_SRC julia
  AFloat(-2.0)
  #+END_SRC
  #+BEGIN_SRC julia
  -2.0_160
  #+END_SRC
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/afloat.jl::14][afloat.jl:14]], [[6AeX459r][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  AFloat(value::T) where {T<:AbstractFloat}
  #+END_SRC
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/afloat.jl::21][afloat.jl:21]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=AFloat32=*  <<nGs1J6uV>>
  #+BEGIN_SRC julia :eval never :exports code
  const AFloat32
  #+END_SRC
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/global.jl::5][global.jl:5]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=AFloat64=*  <<LxmiXjXf>>
  #+BEGIN_SRC julia :eval never :exports code
  const AFloat64
  #+END_SRC
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/global.jl::9][global.jl:9]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=Base.push!=*  <<zf7tYaeV>>
  #+BEGIN_SRC julia :eval never :exports code
  function Base.push!{T,N}(v::Array{T,1},x::NTuple{N,T})::Array{T,1}
  #+END_SRC
  #+BEGIN_QUOTE
  A helper function that push a NTuple into an array
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::57][tape.jl:57]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=Base.show=*  <<Ukl9yGMh>>
  #+BEGIN_SRC julia :eval never :exports code
  Base.show(io::IO, x::AFloat)
  #+END_SRC
  #+BEGIN_QUOTE
  Defines pretty print as explained [[https://docs.julialang.org/en/latest/manual/types/#man-custom-pretty-printing-1][in the official doc]].
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/afloat.jl::24][afloat.jl:24]], [[6AeX459r][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  Base.show(io::IO, x::∂_j)
  #+END_SRC
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::11][tape.jl:11]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=IndexStyle=*  <<OEeK56QQ>>
  #+BEGIN_SRC julia :eval never :exports code
  IndexStyle(::Type{<:AArray{AT,N,P,AIDX}}) where {AT,N,P,AIDX}
  #+END_SRC
  #+BEGIN_QUOTE
  *Design*:
  - [[id:1b16ffef-47fa-473c-b033-de4a864dcaf3][Interface, main methods to redefine]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::120][array.jl:120]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=Tape=*  <<4WCK5yyI>> <<All_Tape>>
  #+BEGIN_SRC julia :eval never :exports code
  mutable struct Tape{T<:AbstractFloat}
  #+END_SRC
  #+BEGIN_QUOTE
  Used to store $d\Phi^{(m)}$ using a storage scheme close to the
  Compressed Row Storage (CRS)

  *Note:* we use =mutable= to have a "by reference" semantic to avoid
   having a tape copy (which would be catastrophic).
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::15][tape.jl:15]], [[6AeX459r][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  function Tape{T<:AbstractFloat}(::Type{T},tape_initial_size::Int = 100)
  #+END_SRC
  #+BEGIN_QUOTE
  Tape constructor
  #+BEGIN_SRC julia
  PragmaticAD.Tape(Float64)
  #+END_SRC
  #+BEGIN_SRC julia
  PragmaticAD.Tape{Float64}([1], PragmaticAD.∂_j{Float64}[])
  #+END_SRC
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::28][tape.jl:28]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=_f_∇f_input_float_to_afloat=*  <<VALruKDq>>
  #+BEGIN_SRC julia :eval never :exports code
  _f_∇f_input_float_to_afloat(x::Array)
  #+END_SRC
  #+BEGIN_QUOTE
  Transforms regular input into autodiff 
  - Array -> AArray
  - Float -> AFloat
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/wrapper.jl::10][wrapper.jl:10]], [[6AeX459r][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  _f_∇f_input_float_to_afloat(x::Number)
  #+END_SRC
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/wrapper.jl::15][wrapper.jl:15]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=_f_∇f_output_grad=*  <<NA3RwPRX>>
  #+BEGIN_SRC julia :eval never :exports code
  function _f_∇f_output_grad(ax::AArray,grad_ay::Array,tpos::Int)
  #+END_SRC
  #+BEGIN_QUOTE
  Transform local gradient into gradient (output)
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/wrapper.jl::18][wrapper.jl:18]], [[6AeX459r][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  function _f_∇f_output_grad(ax::AFloat,grad_ay::Array,tpos::Int)
  #+END_SRC
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/wrapper.jl::25][wrapper.jl:25]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=afloat_count=*  <<YhyLyjGH>>
  #+BEGIN_SRC julia :eval never :exports code
  afloat_count{T}(tape::Tape{T})::Int
  #+END_SRC
  #+BEGIN_QUOTE
  Returns how many [[All_AFloat][struct AFloat]] are stored in the current [[All_Tape][struct Tape]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::51][tape.jl:51]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=afloat_next_index=*  <<GhrMzCNE>>
  #+BEGIN_SRC julia :eval never :exports code
  afloat_next_index{T}(tape::Tape{T})::Int
  #+END_SRC
  #+BEGIN_QUOTE
  Returns a new [[All_AFloat][struct AFloat]] index. Generally used at creation time,
  see [[All_create_tape_record_value][create_tape_record(...)]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::44][tape.jl:44]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=aidx=*  <<PkT9cXFw>>
  #+BEGIN_SRC julia :eval never :exports code
  aidx(aa::AArray)
  #+END_SRC
  #+BEGIN_QUOTE
  The recommended way to access aidx member

  See [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::86][array.jl:86]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=aidx_type=*  <<fPSCBihY>>
  #+BEGIN_SRC julia :eval never :exports code
  aidx_type(::Type{AArray{AT,N,P,AIDX}}) where {AT,N,P,AIDX}
  #+END_SRC
  #+BEGIN_QUOTE
  The recommended way to access aidx member *type*

  See [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::78][array.jl:78]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=create_tape_chunk=*  <<aXCYcFtF>>
  #+BEGIN_SRC julia :eval never :exports code
  function create_tape_chunk(tape::Tape{T},chunk_n::Int) where {T}
  #+END_SRC
  #+BEGIN_QUOTE
  This function allocate a chunk of =chunk_n= new [[All_AFloat][struct AFloat]].
  It returns the index of the first one.
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::58][array.jl:58]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=create_tape_record=*  <<29uzBFDM>>
  #+BEGIN_SRC julia :eval never :exports code
  function create_tape_record{T,N}(tape::Tape{T},value::T,dϕ::NTuple{N,∂_j{T}})::AFloat{T}
  #+END_SRC
  #+BEGIN_QUOTE
  Creates a new differential $d\phi = \sum \partial_j \phi d x_j$ and
  returns the associated [[All_AFloat][struct AFloat]].
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::70][tape.jl:70]], [[6AeX459r][back to index]]
   @@latex:\phantomsection@@  <<All_create_tape_record_value>>
  #+BEGIN_SRC julia :eval never :exports code
  function create_tape_record{T}(tape::Tape{T},value::T)::AFloat{T}
  #+END_SRC
  #+BEGIN_QUOTE
  Creates a new [[All_AFloat][struct AFloat]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::83][tape.jl:83]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=export=*  <<8StxI6z4>>
  #+BEGIN_SRC julia :eval never :exports code
  export AFloat
  #+END_SRC
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/afloat.jl::1][afloat.jl:1]], [[6AeX459r][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  export afloat_count
  #+END_SRC
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::1][tape.jl:1]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=f_gradient=*  <<c1QrUAM2>> <<All_tape_f_gradient>>
  #+BEGIN_SRC julia :eval never :exports code
  function f_gradient{T}(tape::Tape{T},
			 index::Int,
			 stop_at_tape_position::Int)
  #+END_SRC
  #+BEGIN_QUOTE
  Computes differential adjoint vector action (reverse mode)
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::120][tape.jl:120]], [[6AeX459r][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  f_gradient{T}(y::AFloat{T},stop_at_tape_position::Int)
  #+END_SRC
  #+BEGIN_QUOTE
  Convenience function that call [[All_tape_f_gradient][f_gradient(...)]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/wrapper.jl::5][wrapper.jl:5]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=f_∇f=*  <<49aDC1JX>>
  #+BEGIN_SRC julia :eval never :exports code
  function f_∇f(f::Function, argnum::Int=1)
  #+END_SRC
  #+BEGIN_QUOTE
  Wraps a function to compute its value and gradient

  *Note*: inspired from [[https://github.com/denizyuret/AutoGrad.jl/blob/master/src/core.jl][AutoGrad.jl/core.jl]]

  Scalar example:

  #+BEGIN_SRC julia
   f(x,y) = y*sin(x,y)
   af=PragmaticAD.f_∇f(f,2)
   af(2,5.)
  #+END_SRC
  #+BEGIN_SRC julia
  f (generic function with 1 method)
  (::local_f_∇f) (generic function with 1 method)
  ***ERROR***  MethodError(sin, (2, 5.0_161), 0x00000000000056a5)
  #+END_SRC


  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/wrapper.jl::30][wrapper.jl:30]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=getindex=*  <<lICJ7815>>
  #+BEGIN_SRC julia :eval never :exports code
  getindex(aa::AArray{AT}, i::Int) where {AT}
  #+END_SRC
  #+BEGIN_QUOTE
  *Design*:
  - [[id:1b16ffef-47fa-473c-b033-de4a864dcaf3][Interface, main methods to redefine]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::127][array.jl:127]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=increase_size!=*  <<XJFOPg6b>>
  #+BEGIN_SRC julia :eval never :exports code
  function increase_size!(v::Array{T,1},positive_integer::Int)::Int where {T}
  #+END_SRC
  #+BEGIN_QUOTE
  This function increase array size by =positive_integer= and returns
  the initial size
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::47][array.jl:47]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=parent=*  <<jI6UaBxu>>
  #+BEGIN_SRC julia :eval never :exports code
  parent(aa::AArray)
  #+END_SRC
  #+BEGIN_QUOTE
  The recommended way to access parent membe

  See [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::102][array.jl:102]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=parent_type=*  <<YYQzcLzV>>
  #+BEGIN_SRC julia :eval never :exports code
  parent_type(::Type{AArray{AT,N,P,AIDX}}) where {AT,N,P,AIDX}
  #+END_SRC
  #+BEGIN_QUOTE
  The recommended way to access parent member *type*

  See [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::94][array.jl:94]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=rewind_tape!=*  <<8xntlVkB>> <<All_rewind_tape>>
  #+BEGIN_SRC julia :eval never :exports code
  function rewind_tape!{T}(tape::Tape{T},tape_position::Int)
  #+END_SRC
  #+BEGIN_QUOTE
  Rewinds tape

  See: [[All_tape_position][tape_position(...)]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::108][tape.jl:108]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=size=*  <<fybLT82T>>
  #+BEGIN_SRC julia :eval never :exports code
  size(aa::AArray)
  #+END_SRC
  #+BEGIN_QUOTE
  *Design*:
  - [[id:1b16ffef-47fa-473c-b033-de4a864dcaf3][Interface, main methods to redefine]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::113][array.jl:113]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=tape_position=*  <<4GpB304e>> <<All_tape_position>>
  #+BEGIN_SRC julia :eval never :exports code
  tape_position{T}(tape::Tape{T})
  #+END_SRC
  #+BEGIN_QUOTE
  Returns tape position.

  Usage example:

  #+BEGIN_SRC julia :eval never
  tape=PragmaticAD.get_tape(Float64)
  tpos=PragmaticAD.tape_position(tape)
  # some computations
  rewind_tape!(tape,tpos)
  #+END_SRC

  See: [[All_rewind_tape][rewind_tape!(...)]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::92][tape.jl:92]], [[6AeX459r][back to index]]
  - @@latex:\phantomsection@@ *=∂_j=*  <<fh2PaPqA>>
  #+BEGIN_SRC julia :eval never :exports code
  struct ∂_j{T<:Real}
  #+END_SRC
  #+BEGIN_QUOTE
  Used to store partial derivatives $\partial_j$
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::4][tape.jl:4]], [[6AeX459r][back to index]]
  :END:

* Design remarks 
** Array struct design

   The global design has been inspired from these Julia packages:
   - [[https://github.com/JuliaArrays/OffsetArrays.jl/blob/master/src/OffsetArrays.jl][OffsetArrays.jl]]
   - [[https://github.com/JuliaArrays/StaticArrays.jl][StaticArrays.jl]]

*** Multiple parameters in the struct definition 
    :PROPERTIES:
    :ID:       c39435d9-532c-4390-8089-bde4c5e53f3e
    :END:
    The [[All_AArray][AArray]] class can possibly have a quite large number of parameters
    (here =T,N,AIDX,O=). In order to decouple this parametrization from
    the future method implementations we use the following guideline.

    Define =foo= as follows:
    #+BEGIN_SRC julia :eval never 
foo(aa:AArray) = ...
    #+END_SRC
    and not as follows:
    #+BEGIN_SRC julia :eval never 
foo(aa::AArray{T,N,P,AIDX}) where {T,N,P,AIDX} = ...
    #+END_SRC
    In this former code we see that any change in the parameter lists will break =foo= function code.

    As a consequence, one must define a *restricted number* of helper
    functions like
    #+BEGIN_SRC julia :eval never 
aidx_type(::Type{AArray{T,N,P,AIDX}}) where {T,N,P,AIDX} = AIDX
... same for T,N,P and that is all!
    #+END_SRC

*** Restricted set of constructors
    :PROPERTIES:
    :ID:       b384f347-8c27-42ae-9759-2914d67cad4d
    :END:

    There are a lot of Array types in Julia 
    #+BEGIN_EXAMPLE
julia> subtypes(AbstractArray)
24-element Array{Union{DataType, UnionAll},1}:
 AbstractSparseArray                      
 Bidiagonal                               
 ConjArray                                
 Core.Inference.Range                     
 DenseArray                               
 ...
    #+END_EXAMPLE
    with some variations that can lead to unexpected bugs if we blindly use a generic approach.
    In order to control type variability we use an inner constructor. From Julia doc:
    #+BEGIN_QUOTE
    Without any explicitly provided inner constructors, the declaration of
    the composite type Point{T<:Real} automatically provides an inner
    constructor, Point{T}, for each possible type T<:Real, that behaves
    just like non-parametric default inner constructors do. It also
    provides a single general outer Point constructor that takes pairs of
    real arguments, which must be of the same type.
    #+END_QUOTE

    This mechanism allows use to explicitly control available implementations:

    #+BEGIN_SRC julia :eval never
julia> struct X{T}
           x::T

           X(n::I) where {I<:Integer} = new{I}(n)
       end

julia> X(5)
X{Int64}(5)

julia> X(5.0)
ERROR: MethodError: Cannot `convert` an object of type Float64 to an object of type X
This may have arisen from a call to the constructor X(...),
since type constructors fall back to convert methods.
Stacktrace:
 [1] X(::Float64) at ./sysimg.jl:77
    #+END_SRC

*** Interface, main methods to redefine
    :PROPERTIES:
    :ID:       1b16ffef-47fa-473c-b033-de4a864dcaf3
    :END:


    Methods to implement can be found [[https://docs.julialang.org/en/stable/manual/interfaces/#man-interface-array-1][here]] (official julia doc)

    The idea is to reuse as much a possible =parent='s methods.

**** Remark
     :PROPERTIES:
     :ID:       ffb7408e-cb7b-4c7e-a1f8-39c3af3d37d5
     :END:

     CAVEAT: my first attempt was to write =getindex(parent(aa),I)= as follows:

     #+BEGIN_SRC julia :eval never
  @inline Base.getindex(aa::AArray{AT,N,P}, I::Vararg{Int, N}) where {AT,N,P} = AT(getindex(parent(aa),I...),getindex(aidx(aa),I...))
     #+END_SRC
     which gives this:
     #+BEGIN_EXAMPLE
ERROR: ArgumentError: invalid index: (1, 1)
Stacktrace:
[1] getindex(::Array{Float64,2}, ::Tuple{Int64,Int64}) at ./abstractarray.jl:883
     #+END_EXAMPLE
  
     The correct form is:
     #+BEGIN_SRC julia :eval never
  @inline Base.getindex(aa::AArray{AT,N,P}, I::Vararg{Int, N}) where {AT,N,P} = AT(getindex(parent(aa),I...),getindex(aidx(aa),I...))
     #+END_SRC

**** TODO [0/1]

- [ ] implement:
#+BEGIN_EXAMPLE
function Base.similar(aa::AArray{T,N,P}, ::Type{TS}, dims::Dims) where {T,TS,N,P}
    return similar(parent(A), T, dims)
end
#+END_EXAMPLE

** Specialization of common functions
   :PROPERTIES:
   :ID:       66703b8c-0f31-49db-bf41-268758ac27a9
   :END:

*** TODO Overloading ambiguity [0/1]

 - [ ] understand *exactly* why

 I first wrote:
 #+BEGIN_SRC julia :eval never
==(x1::AFloat{T},x2::T) where {T} = (x1.value == x2)
 #+END_SRC
but got:
#+BEGIN_EXAMPLE
  Expression: aa[2, 3] == a[2, 3]
  MethodError: ==(::PragmaticAD.AFloat{Float64}, ::Float64) is ambiguous. Candidates:
    ==(x1::PragmaticAD.AFloat{T}, x2::T) where T in PragmaticAD at /home/picaud/GitHub/PragmaticAD.jl/src/tape.jl:190
    ==(x::Number, y::Number) in Base at promotion.jl:290
  Possible fix, define
    ==(::PragmaticAD.AFloat{T>:Number}, ::Number)
#+END_EXAMPLE
 The right way to do things seems to be:
 #+BEGIN_SRC julia :eval never
==(x1::AFloat{T},x2::Number) where {T} = (x1.value == x2)
 #+END_SRC

*** Code generator

Instead of:
 #+BEGIN_SRC julia :eval never 
import Base: (==)

==(x1::AFloat{T},x2::AFloat{T}) where {T} = (x1.value == x2.value)
==(x1::AFloat{T},x2::Number) where {T} = (x1.value == x2)
==(x1::Number,x2::AFloat{T}) where {T} = (x1 == x2.value)
 #+END_SRC

 a possible automation is:

 #+BEGIN_SRC julia :eval never 
for op = (:(==), :(<))
    @eval begin
        import Base: ($op)
        ($op)(x1::AFloat{T},x2::AFloat{T}) where {T} = ($op)(x1.value,x2.value)
        ($op)(x1::AFloat{T},x2::Number) where {T} = ($op)(x1.value,x2)
        ($op)(x1::Number,x2::AFloat{T}) where {T} = ($op)(x1,x2.value)
    end
end
 #+END_SRC

*CAVEAT*: 
Syntax, one must write
#+BEGIN_EXAMPLE
($op)(x1.value,x2)
#+END_EXAMPLE
and not
#+BEGIN_EXAMPLE
(x1.value $op x2)
#+END_EXAMPLE

* Unit tests

  #+BEGIN_SRC julia :results output table :exports results
include("/home/picaud/GitHub/PragmaticAD.jl/test/runtests.jl")
  #+END_SRC

  #+RESULTS:
  : WARNING: Method definition f_∇f(Function) in module PragmaticAD at /home/picaud/GitHub/PragmaticAD.jl/src/wrapper.jl:45 overwritten at /home/picaud/GitHub/PragmaticAD.jl/src/wrapper.jl:45.
  : WARNING: Method definition f_∇f(Function, Int64) in module PragmaticAD at /home/picaud/GitHub/PragmaticAD.jl/src/wrapper.jl:45 overwritten at /home/picaud/GitHub/PragmaticAD.jl/src/wrapper.jl:45.
  : Test Summary: | Pass  Total
  : PragmaticAD   |    9      9
