#+SETUPFILE: ./Setup/setupFile.org
#+TITLE: Pragmatic automatic differentiation
#+PROPERTY: header-args:julia :session *pad_session*  :exports code :eval no-export
#+LATEX_HEADER: \usepackage{stmaryrd}

#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted[]{
  bgcolor=bg,
  breaklines=true,
  breakanywhere=true,
  mathescape,
  fontsize=\footnotesize}
#+END_EXPORT

#+BEGIN_SRC julia :exports none
using Revise
using PragmaticAD
using J4Org

initialize_boxing_module(usedModules=["PragmaticAD"])
#+END_SRC

#+RESULTS:

* Introduction

* API documentation 

  #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/PragmaticAD.jl/src/");
print_org_doc(documented_items,tag="API",header_level=0)
  #+END_SRC

  #+RESULTS:
  :RESULTS:

<<iKkCchMr>> *Index:* *[A]* [[bXIf1ThZ][AArray]], [[XrCKNICr][AFloat]] 
- @@latex:\phantomsection@@ *=AArray=*  <<bXIf1ThZ>> <<pGeIM1vnAArray>>
#+BEGIN_SRC julia :eval never :exports code
struct AArray{AT<:AFloat,N,P<:AbstractArray,AIDX}  <: AbstractArray{AT,N}
#+END_SRC
#+BEGIN_QUOTE
This is the array type to use in place of built-in Julia =Array{T,N}= types.

*Parameters*:

- =AIDX= is an extra parameter defining how [[pGeIM1vnAFloat][struct AFloat]] indices are
  stored. This type can be different from =P=. For instance in case
  of sparse matrix, only an uni-dimensional array to store indices
  associated to non-zero components is required, no need to the
  store sparsity pattern twice. 

*Design*:
- [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]

#+END_QUOTE
[[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::3][array.jl:3]], [[iKkCchMr][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function AArray(p::Array{T,N}) where {T<:AbstractFloat,N}
#+END_SRC
#+BEGIN_QUOTE
Construction from an "usual" Julia array of real numbers.

Usage example:

#+BEGIN_SRC julia
AArray(rand(2,1))
#+END_SRC

#+RESULTS:
| PragmaticAD.AFloat{Float64}(0.24475618878823702 | 15) |
| PragmaticAD.AFloat{Float64}(0.7719785904922678  | 16) |

#+BEGIN_SRC julia
2×1 PragmaticAD.AArray{PragmaticAD.AFloat{Float64},2,Array{Float64,2},Array{Int64,2}}:
 PragmaticAD.AFloat{Float64}(0.575999, 13)
 PragmaticAD.AFloat{Float64}(0.524417, 14)
#+END_SRC

#+RESULTS:
| PragmaticAD.AFloat{Float64}(0.524417 | 14) |

*Design*:
- [[id:b384f347-8c27-42ae-9759-2914d67cad4d][Restricted set of constructors]]
#+END_QUOTE
[[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::22][array.jl:22]], [[iKkCchMr][back to index]]
- @@latex:\phantomsection@@ *=AFloat=*  <<XrCKNICr>> <<pGeIM1vnAFloat>>
#+BEGIN_SRC julia :eval never :exports code
struct AFloat{T<:AbstractFloat} <: Real
#+END_SRC
#+BEGIN_QUOTE
Specialization of number alllowing to track and record operations in the _struct Tape_
#+END_QUOTE
[[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::35][tape.jl:35]], [[iKkCchMr][back to index]]
  :END:

* Internal documentation

  #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/PragmaticAD.jl/src/");
print_org_doc(documented_items,link_prefix="All_", header_level=0)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # =WARNING:= cannot interpret /home/picaud/GitHub/PragmaticAD.jl/src/array.jl:3 AssertionError("code != nothing")
  # =WARNING:= cannot interpret /home/picaud/GitHub/PragmaticAD.jl/src/array.jl:135 AssertionError("code != nothing")
  # =WARNING:= cannot interpret /home/picaud/GitHub/PragmaticAD.jl/src/array.jl:143 AssertionError("code != nothing")
  # =WARNING:= cannot interpret /home/picaud/GitHub/PragmaticAD.jl/src/array.jl:156 AssertionError("code != nothing")
  <<Gkld0Zk4>> *Index:* *[A]* [[tX42c0XO][AArray]], [[vxX8Fn3D][AFloat]] *[B]* [[31fHC981][Base.push!]], [[EOp02P07][Base.show]] *[I]* [[AwASL4Ms][IndexStyle]] *[T]* [[ublwSrkt][Tape]] *[a]* [[ceo4adIV][afloat_count]], [[zyDzUVMQ][afloat_next_index]], [[oGw03ufF][aidx]], [[sLUcfW1T][aidx_type]] *[c]* [[Ei4XL21M][create_tape_chunk]], [[anzfs1Pq][create_tape_record]] *[e]* [[LiraDiSX][export]] *[f]* [[YxuF8Doy][f_gradient]] *[g]* [[O8FGvPa2][getindex]] *[i]* [[xgEpSxC8][increase_size!]] *[p]* [[yszQKaJj][parent]], [[M46lwP8M][parent_type]] *[r]* [[7knU3NbM][rewind_tape!]] *[s]* [[JTkZhO71][size]] *[t]* [[d50C4xO4][tape_position]] *[∂]* [[32EfSl0Z][∂_j]] 
  - @@latex:\phantomsection@@ *=AArray=*  <<tX42c0XO>> <<All_AArray>>
  #+BEGIN_SRC julia :eval never :exports code
  struct AArray{AT<:AFloat,N,P<:AbstractArray,AIDX}  <: AbstractArray{AT,N}
  #+END_SRC
  #+BEGIN_QUOTE
  This is the array type to use in place of built-in Julia =Array{T,N}= types.

  *Parameters*:

  - =AIDX= is an extra parameter defining how [[All_AFloat][struct AFloat]] indices are
    stored. This type can be different from =P=. For instance in case
    of sparse matrix, only an uni-dimensional array to store indices
    associated to non-zero components is required, no need to the
    store sparsity pattern twice. 

  *Design*:
  - [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]

  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::6][array.jl:6]], [[Gkld0Zk4][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  function AArray(p::Array{T,N}) where {T<:AbstractFloat,N}
  #+END_SRC
  #+BEGIN_QUOTE
  Construction from an "usual" Julia array of real numbers.

  Usage example:

  #+BEGIN_SRC julia
  AArray(rand(2))
  AArray(rand(2,3))
  #+END_SRC
  #+BEGIN_SRC julia
  2-element PragmaticAD.AArray{PragmaticAD.AFloat{Float64},1,Array{Float64,1},Array{Int64,1}}:
   0.3973_45  
   0.437492_46
  2×3 PragmaticAD.AArray{PragmaticAD.AFloat{Float64},2,Array{Float64,2},Array{Int64,2}}:
   0.532624_47  0.585252_49  0.933764_51  
   0.166291_48  0.439554_50  0.00963996_52
  #+END_SRC

  *Design*:
  - [[id:b384f347-8c27-42ae-9759-2914d67cad4d][Restricted set of constructors]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::25][array.jl:25]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=AFloat=*  <<vxX8Fn3D>> <<All_AFloat>>
  #+BEGIN_SRC julia :eval never :exports code
  struct AFloat{T<:AbstractFloat} <: Number
  #+END_SRC
  #+BEGIN_QUOTE
  Specialization of number alllowing to track and record operations in the [[All_Tape][struct Tape]]

  - TODO [ ] support complex numbers (use [[https://en.wikipedia.org/wiki/Wirtinger_derivatives][Wirtinger_derivatives]]).
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::40][tape.jl:40]], [[Gkld0Zk4][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  AFloat{T}(value::S) where {T<:AbstractFloat,S<:Real}
  #+END_SRC
  #+BEGIN_QUOTE
  Creates a new [[All_AFloat][struct AFloat]] from its value.
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::50][tape.jl:50]], [[Gkld0Zk4][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  AFloat(value::T) where {T<:AbstractFloat}
  #+END_SRC
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::55][tape.jl:55]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=Base.push!=*  <<31fHC981>>
  #+BEGIN_SRC julia :eval never :exports code
  function Base.push!{T,N}(v::Array{T,1},x::NTuple{N,T})::Array{T,1}
  #+END_SRC
  #+BEGIN_QUOTE
  A helper function that push a NTuple into an array
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::87][tape.jl:87]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=Base.show=*  <<EOp02P07>>
  #+BEGIN_SRC julia :eval never :exports code
  Base.show(io::IO, x::AFloat)
  #+END_SRC
  #+BEGIN_QUOTE
  Defines pretty print as explained [[https://docs.julialang.org/en/latest/manual/types/#man-custom-pretty-printing-1][in the official doc]].
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::58][tape.jl:58]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=IndexStyle=*  <<AwASL4Ms>>
  #+BEGIN_SRC julia :eval never :exports code
  IndexStyle(::Type{<:AArray{AT,N,P,AIDX}}) where {AT,N,P,AIDX}
  #+END_SRC
  #+BEGIN_QUOTE
  *Design*:
  - [[id:1b16ffef-47fa-473c-b033-de4a864dcaf3][Interface, main methods to redefine]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::120][array.jl:120]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=Tape=*  <<ublwSrkt>> <<All_Tape>>
  #+BEGIN_SRC julia :eval never :exports code
  mutable struct Tape{T<:AbstractFloat}
  #+END_SRC
  #+BEGIN_QUOTE
  Used to store $d\Phi^{(m)}$ using a storage scheme close to the
  Compressed Row Storage (CRS)

  *Note:* we use =mutable= to have a "by reference" semantic to avoid
   having a tape copy (which would be catastrophic).
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::13][tape.jl:13]], [[Gkld0Zk4][back to index]]

  #+BEGIN_SRC julia :eval never :exports code
  function Tape{T<:AbstractFloat}(::Type{T},tape_initial_size::Int = 100)
  #+END_SRC
  #+BEGIN_QUOTE
  Tape constructor
  #+BEGIN_SRC julia
  PragmaticAD.Tape(Float64)
  #+END_SRC
  #+BEGIN_SRC julia
  PragmaticAD.Tape{Float64}([1], PragmaticAD.∂_j{Float64}[])
  #+END_SRC
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::26][tape.jl:26]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=afloat_count=*  <<ceo4adIV>>
  #+BEGIN_SRC julia :eval never :exports code
  afloat_count{T}(tape::Tape{T})::Int
  #+END_SRC
  #+BEGIN_QUOTE
  Returns how many [[All_AFloat][struct AFloat]] are stored in the current [[All_Tape][struct Tape]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::81][tape.jl:81]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=afloat_next_index=*  <<zyDzUVMQ>>
  #+BEGIN_SRC julia :eval never :exports code
  afloat_next_index{T}(tape::Tape{T})::Int
  #+END_SRC
  #+BEGIN_QUOTE
  Returns a new [[All_AFloat][struct AFloat]] index. Generally used at creation time,
  see [[All_create_tape_record_value][create_tape_record(...)]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::74][tape.jl:74]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=aidx=*  <<oGw03ufF>>
  #+BEGIN_SRC julia :eval never :exports code
  aidx(aa::AArray)
  #+END_SRC
  #+BEGIN_QUOTE
  The recommended way to access aidx member

  See [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::86][array.jl:86]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=aidx_type=*  <<sLUcfW1T>>
  #+BEGIN_SRC julia :eval never :exports code
  aidx_type(::Type{AArray{AT,N,P,AIDX}}) where {AT,N,P,AIDX}
  #+END_SRC
  #+BEGIN_QUOTE
  The recommended way to access aidx member *type*

  See [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::78][array.jl:78]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=create_tape_chunk=*  <<Ei4XL21M>>
  #+BEGIN_SRC julia :eval never :exports code
  function create_tape_chunk(tape::Tape{T},chunk_n::Int) where {T}
  #+END_SRC
  #+BEGIN_QUOTE
  This function allocate a chunk of =chunk_n= new [[All_AFloat][struct AFloat]].
  It returns the index of the first one.
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::58][array.jl:58]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=create_tape_record=*  <<anzfs1Pq>>
  #+BEGIN_SRC julia :eval never :exports code
  function create_tape_record{T,N}(tape::Tape{T},value::T,dϕ::NTuple{N,∂_j{T}})::AFloat{T}
  #+END_SRC
  #+BEGIN_QUOTE
  Creates a new differential $d\phi = \sum \partial_j \phi d x_j$ and
  returns the associated [[All_AFloat][struct AFloat]].
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::100][tape.jl:100]], [[Gkld0Zk4][back to index]]
   @@latex:\phantomsection@@  <<All_create_tape_record_value>>
  #+BEGIN_SRC julia :eval never :exports code
  function create_tape_record{T}(tape::Tape{T},value::T)::AFloat{T}
  #+END_SRC
  #+BEGIN_QUOTE
  Creates a new [[All_AFloat][struct AFloat]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::113][tape.jl:113]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=export=*  <<LiraDiSX>>
  #+BEGIN_SRC julia :eval never :exports code
  export AFloat, afloat_count
  #+END_SRC
  #+BEGIN_QUOTE
  Exported symbols
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::1][tape.jl:1]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=f_gradient=*  <<YxuF8Doy>>
  #+BEGIN_SRC julia :eval never :exports code
  function f_gradient{T}(tape::Tape{T},
			 index::Int,
			 stop_at_tape_position::Int)
  #+END_SRC
  #+BEGIN_QUOTE
  Computes differential adjoint vector action (reverse mode)
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::169][tape.jl:169]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=getindex=*  <<O8FGvPa2>>
  #+BEGIN_SRC julia :eval never :exports code
  getindex(aa::AArray{AT}, i::Int) where {AT}
  #+END_SRC
  #+BEGIN_QUOTE
  *Design*:
  - [[id:1b16ffef-47fa-473c-b033-de4a864dcaf3][Interface, main methods to redefine]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::127][array.jl:127]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=increase_size!=*  <<xgEpSxC8>>
  #+BEGIN_SRC julia :eval never :exports code
  function increase_size!(v::Array{T,1},positive_integer::Int)::Int where {T}
  #+END_SRC
  #+BEGIN_QUOTE
  This function increase array size by =positive_integer= and returns
  the initial size
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::47][array.jl:47]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=parent=*  <<yszQKaJj>>
  #+BEGIN_SRC julia :eval never :exports code
  parent(aa::AArray)
  #+END_SRC
  #+BEGIN_QUOTE
  The recommended way to access parent membe

  See [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::102][array.jl:102]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=parent_type=*  <<M46lwP8M>>
  #+BEGIN_SRC julia :eval never :exports code
  parent_type(::Type{AArray{AT,N,P,AIDX}}) where {AT,N,P,AIDX}
  #+END_SRC
  #+BEGIN_QUOTE
  The recommended way to access parent member *type*

  See [[id:c39435d9-532c-4390-8089-bde4c5e53f3e][Multiple parameters in the struct definition]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::94][array.jl:94]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=rewind_tape!=*  <<7knU3NbM>> <<All_rewind_tape>>
  #+BEGIN_SRC julia :eval never :exports code
  function rewind_tape!{T}(tape::Tape{T},tape_position::Int)
  #+END_SRC
  #+BEGIN_QUOTE
  Rewinds tape

  See: [[All_tape_position][tape_position(...)]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::138][tape.jl:138]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=size=*  <<JTkZhO71>>
  #+BEGIN_SRC julia :eval never :exports code
  size(aa::AArray)
  #+END_SRC
  #+BEGIN_QUOTE
  *Design*:
  - [[id:1b16ffef-47fa-473c-b033-de4a864dcaf3][Interface, main methods to redefine]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/array.jl::113][array.jl:113]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=tape_position=*  <<d50C4xO4>> <<All_tape_position>>
  #+BEGIN_SRC julia :eval never :exports code
  tape_position{T}(tape::Tape{T})
  #+END_SRC
  #+BEGIN_QUOTE
  Returns tape position.

  Usage example:

  #+BEGIN_SRC julia :eval never
  tape=PragmaticAD.get_tape(Float64)
  tpos=PragmaticAD.tape_position(tape)
  # some computations
  rewind_tape!(tape,tpos)
  #+END_SRC

  See: [[All_rewind_tape][rewind_tape!(...)]]
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::122][tape.jl:122]], [[Gkld0Zk4][back to index]]
  - @@latex:\phantomsection@@ *=∂_j=*  <<32EfSl0Z>>
  #+BEGIN_SRC julia :eval never :exports code
  struct ∂_j{T<:Real}
  #+END_SRC
  #+BEGIN_QUOTE
  Used to store partial derivatives $\partial_j$
  #+END_QUOTE
  [[file:/home/picaud/GitHub/PragmaticAD.jl/src/tape.jl::6][tape.jl:6]], [[Gkld0Zk4][back to index]]
  :END:

* Design remarks 
** Array struct design

   The global design has been inspired from these Julia packages:
   - [[https://github.com/JuliaArrays/OffsetArrays.jl/blob/master/src/OffsetArrays.jl][OffsetArrays.jl]]
   - [[https://github.com/JuliaArrays/StaticArrays.jl][StaticArrays.jl]]

*** Multiple parameters in the struct definition 
    :PROPERTIES:
    :ID:       c39435d9-532c-4390-8089-bde4c5e53f3e
    :END:
    The [[All_AArray][AArray]] class can possibly have a quite large number of parameters
    (here =T,N,AIDX,O=). In order to decouple this parametrization from
    the future method implementations we use the following guideline.

    Define =foo= as follows:
    #+BEGIN_SRC julia :eval never 
foo(aa:AArray) = ...
    #+END_SRC
    and not as follows:
    #+BEGIN_SRC julia :eval never 
foo(aa::AArray{T,N,P,AIDX}) where {T,N,P,AIDX} = ...
    #+END_SRC
    In this former code we see that any change in the parameter lists will break =foo= function code.

    As a consequence, one must define a *restricted number* of helper
    functions like
    #+BEGIN_SRC julia :eval never 
aidx_type(::Type{AArray{T,N,P,AIDX}}) where {T,N,P,AIDX} = AIDX
... same for T,N,P and that is all!
    #+END_SRC

*** Restricted set of constructors
    :PROPERTIES:
    :ID:       b384f347-8c27-42ae-9759-2914d67cad4d
    :END:

    There are a lot of Array types in Julia 
    #+BEGIN_EXAMPLE
julia> subtypes(AbstractArray)
24-element Array{Union{DataType, UnionAll},1}:
 AbstractSparseArray                      
 Bidiagonal                               
 ConjArray                                
 Core.Inference.Range                     
 DenseArray                               
 ...
    #+END_EXAMPLE
    with some variations that can lead to unexpected bugs if we blindly use a generic approach.
    In order to control type variability we use an inner constructor. From Julia doc:
    #+BEGIN_QUOTE
    Without any explicitly provided inner constructors, the declaration of
    the composite type Point{T<:Real} automatically provides an inner
    constructor, Point{T}, for each possible type T<:Real, that behaves
    just like non-parametric default inner constructors do. It also
    provides a single general outer Point constructor that takes pairs of
    real arguments, which must be of the same type.
    #+END_QUOTE

    This mechanism allows use to explicitly control available implementations:

    #+BEGIN_SRC julia :eval never
julia> struct X{T}
           x::T

           X(n::I) where {I<:Integer} = new{I}(n)
       end

julia> X(5)
X{Int64}(5)

julia> X(5.0)
ERROR: MethodError: Cannot `convert` an object of type Float64 to an object of type X
This may have arisen from a call to the constructor X(...),
since type constructors fall back to convert methods.
Stacktrace:
 [1] X(::Float64) at ./sysimg.jl:77
    #+END_SRC

*** Interface, main methods to redefine
    :PROPERTIES:
    :ID:       1b16ffef-47fa-473c-b033-de4a864dcaf3
    :END:


    Methods to implement can be found [[https://docs.julialang.org/en/stable/manual/interfaces/#man-interface-array-1][here]] (official julia doc)

    The idea is to reuse as much a possible =parent='s methods.

**** Remark
     :PROPERTIES:
     :ID:       ffb7408e-cb7b-4c7e-a1f8-39c3af3d37d5
     :END:

     CAVEAT: my first attempt was to write =getindex(parent(aa),I)= as follows:

     #+BEGIN_SRC julia :eval never
  @inline Base.getindex(aa::AArray{AT,N,P}, I::Vararg{Int, N}) where {AT,N,P} = AT(getindex(parent(aa),I...),getindex(aidx(aa),I...))
     #+END_SRC
     which gives this:
     #+BEGIN_EXAMPLE
ERROR: ArgumentError: invalid index: (1, 1)
Stacktrace:
[1] getindex(::Array{Float64,2}, ::Tuple{Int64,Int64}) at ./abstractarray.jl:883
     #+END_EXAMPLE
  
     The correct form is:
     #+BEGIN_SRC julia :eval never
  @inline Base.getindex(aa::AArray{AT,N,P}, I::Vararg{Int, N}) where {AT,N,P} = AT(getindex(parent(aa),I...),getindex(aidx(aa),I...))
     #+END_SRC

**** TODO [0/1]

- [ ] implement:
#+BEGIN_EXAMPLE
function Base.similar(aa::AArray{T,N,P}, ::Type{TS}, dims::Dims) where {T,TS,N,P}
    return similar(parent(A), T, dims)
end
#+END_EXAMPLE

** Specialization of common functions
   :PROPERTIES:
   :ID:       66703b8c-0f31-49db-bf41-268758ac27a9
   :END:

*** TODO Overloading ambiguity [0/1]

 - [ ] understand *exactly* why

 I first wrote:
 #+BEGIN_SRC julia :eval never
==(x1::AFloat{T},x2::T) where {T} = (x1.value == x2)
 #+END_SRC
but got:
#+BEGIN_EXAMPLE
  Expression: aa[2, 3] == a[2, 3]
  MethodError: ==(::PragmaticAD.AFloat{Float64}, ::Float64) is ambiguous. Candidates:
    ==(x1::PragmaticAD.AFloat{T}, x2::T) where T in PragmaticAD at /home/picaud/GitHub/PragmaticAD.jl/src/tape.jl:190
    ==(x::Number, y::Number) in Base at promotion.jl:290
  Possible fix, define
    ==(::PragmaticAD.AFloat{T>:Number}, ::Number)
#+END_EXAMPLE
 The right way to do things seems to be:
 #+BEGIN_SRC julia :eval never
==(x1::AFloat{T},x2::Number) where {T} = (x1.value == x2)
 #+END_SRC

*** Code generator

Instead of:
 #+BEGIN_SRC julia :eval never 
import Base: (==)

==(x1::AFloat{T},x2::AFloat{T}) where {T} = (x1.value == x2.value)
==(x1::AFloat{T},x2::Number) where {T} = (x1.value == x2)
==(x1::Number,x2::AFloat{T}) where {T} = (x1 == x2.value)
 #+END_SRC

 a possible automation is:

 #+BEGIN_SRC julia :eval never 
for op = (:(==), :(<))
    @eval begin
        import Base: ($op)
        ($op)(x1::AFloat{T},x2::AFloat{T}) where {T} = ($op)(x1.value,x2.value)
        ($op)(x1::AFloat{T},x2::Number) where {T} = ($op)(x1.value,x2)
        ($op)(x1::Number,x2::AFloat{T}) where {T} = ($op)(x1,x2.value)
    end
end
 #+END_SRC

*CAVEAT*: 
Syntax, one must write
#+BEGIN_EXAMPLE
($op)(x1.value,x2)
#+END_EXAMPLE
and not
#+BEGIN_EXAMPLE
(x1.value $op x2)
#+END_EXAMPLE

* Unit tests

  #+BEGIN_SRC julia :results output table :exports results
include("/home/picaud/GitHub/PragmaticAD.jl/test/runtests.jl")
  #+END_SRC

  #+RESULTS:
  : Test Summary: | Pass  Total
  : PragmaticAD   |    2      2
